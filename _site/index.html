<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>eucalypt</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="eucalypt" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/" />
<meta property="og:url" content="http://localhost:4000/" />
<meta property="og:site_name" content="eucalypt" />
<script type="application/ld+json">
{"name":"eucalypt","@type":"WebSite","url":"http://localhost:4000/","headline":"eucalypt","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=8114a9d47733a9208d9337fd4753137655113777">
    <script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
    <script src="/assets/js/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="/assets/css/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
	<nav>
	  <li class="fork"><a href="http://github.com/curvelogic/eucalypt">View On GitHub</a></li>
	  
	</nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
	<div id="title">
	  <h1>eucalypt</h1>
	  <p></p>
	  <hr>
	  <span class="credits left">Project maintained by <a href="http://github.com/curvelogic">curvelogic</a></span>
	  <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
	</div>

	
<p><span style="color: red; font-weight: bold"> Eucalypt is in an
experimental phase of development. Much of this does not yet exist.
The introduction is here to act like a product specification, guiding
development. It is highly subject to change and perpetually at risk of
destruction. In short, go away and come back later. </span></p>

<p>Eucalypt is a tool, and a little language, for generating and
transforming structured data formats like YAML and JSON.</p>

<p>If you use text-based templating to process these formats or you pipe
this these formats through several different tools or build steps,
Eucalypt should be able to help you generate your output more cleanly
and with fewer cognitive somersaults.</p>

<p>Eucalypt is a purely functional language that can be used quickly and
easily from the command line.</p>

<p>It has the following features:</p>
<ul>
  <li>a native syntax that makes common transformations succint and
 allows you to define data, functions, operators and more</li>
  <li>a simple means of embedding in YAML files to support in-place
manipulation of the data (a la templating approaches)</li>
  <li>facilities for manipulating blocks (think JSON objects, YAML
 mappings)</li>
  <li>facilities for manipulating text including string interpolation
and regular expression</li>
  <li>an ergonomic command line interface and access to environment
 variables, the filesystem…</li>
  <li>metadata annotations and numerous extension points</li>
</ul>

<p>If you’re generating or processing YAML or JSON, you should give it a
try.</p>

<h1 id="a-lightning-tour-of-the-eucalypts-native-syntax">A lightning tour of the Eucalypt’s native syntax</h1>

<p>A few micro-examples should help give a flavour of Eucalypt’s native
syntax.</p>

<h2 id="example-one">Example One</h2>

<p>Here is a simple one:</p>

<pre><code class="language-eu">target-zones: ["a", "b", "c"] map("eu-west-1{}")
</code></pre>

<p>You can put this in a file named <code class="highlighter-rouge">test.eu</code> and run it with <code class="highlighter-rouge">eu
test.eu</code>. This generates the following YAML:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">target-zones</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">eu-west-1a</span>
  <span class="pi">-</span> <span class="s">eu-west-1b</span>
  <span class="pi">-</span> <span class="s">eu-west-1c</span>
</code></pre></div></div>

<p>Although we’re looking at the native Eucalypt syntax here, this
example could just as easily be embedded directly in a YAML file using
the <code class="highlighter-rouge">!eu</code> tag. Pop the following in a <code class="highlighter-rouge">test.yaml</code> file and process it
with <code class="highlighter-rouge">eu test.yaml</code>. You’ll get the same result.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">target-zones</span><span class="pi">:</span> <span class="kt">!eu</span> <span class="pi">[</span><span class="s2">"</span><span class="s">a"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">b"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">c"</span><span class="pi">]</span> <span class="s">map("eu-west-1{}")</span>
</code></pre></div></div>

<p>First, this example illustrates how we apply transformations like
<code class="highlighter-rouge">map</code> simply by concatenation.</p>

<p>In fact this is nothing more than a function call but this feature
allows us to write things in an order which makes the processing
clear.</p>

<p>In this example, <code class="highlighter-rouge">map</code> is just a function of two parameters. Its first
argument is provided in parentheses and its second argument is the
value of what came before.</p>

<blockquote>
  <p>Users of languages like Elixir or OCaml may recognise an implicit
<code class="highlighter-rouge">|&gt;</code> operator here. Clojure users may see an invisible threading
macro. Note that writing elements next to each other like this gives
you the <em>reverse</em> of what you might expect in Haskell or OCaml or
Lisp: we write <code class="highlighter-rouge">x f</code> <em>not</em> <code class="highlighter-rouge">f x</code>.</p>
</blockquote>

<p>There is a lot of freedom in Eucalypt to express ideas in different
ways and develop colorful and cryptic expressions. In a larger or
more ambitious language this could be viewed as rope to hang yourself
with. You will be careful won’t you?</p>

<p>The string template, <code class="highlighter-rouge">"eu-west-1{}"</code> actually defines a function of
one argument that returns a string. The key ingredients here are:</p>

<ul>
  <li>the interpolation syntax <code class="highlighter-rouge">"{...}"</code> which allows values to be inserted
into the string</li>
  <li>the (hidden) use of numeric <em>anaphora</em> in the interpolation syntax
(<code class="highlighter-rouge">{0}</code>, <code class="highlighter-rouge">{1}</code>, <code class="highlighter-rouge">{2}</code>, …) which cause the string to define a
function, not just sequence of characters</li>
  <li>the use of the <em>unnumbered anaphor</em> (<code class="highlighter-rouge">{}</code>) which is numbered
automatically for us, so in this case, <code class="highlighter-rouge">{}</code> is a convenient synonym
for <code class="highlighter-rouge">{0}</code> - the first argument</li>
</ul>

<blockquote>
  <p>Anaphora crop up in various contexts in Eucalypt and are generally
preferable to the full generality of lambdas. If the idea is too
complex to be expressed with anaphora, it should generally be
explicitly named.</p>
</blockquote>

<p>So:</p>

<pre><code class="language-eu">a: 42 "The answer is {0}"
</code></pre>

<p>renders as</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">a</span><span class="pi">:</span> <span class="s">The answer is 42</span>
</code></pre></div></div>

<p>Eucalypt also has <em>expression anaphora</em> which use underscores -
<code class="highlighter-rouge">x: _0 + _1</code>.</p>

<blockquote>
  <p>Users of Groovy or Kotlin may recognise an equivalent of the <code class="highlighter-rouge">it</code>
parameter. Seasoned Lisp hackers are familiar with anaphoric macros.
Clojure users will recognise the <code class="highlighter-rouge">%</code>, <code class="highlighter-rouge">%1</code>, <code class="highlighter-rouge">%2</code> forms usable in
<code class="highlighter-rouge">#(...)</code> contexts. Unlike Clojure’s <code class="highlighter-rouge">%</code> repeated uses of unnumbered
anaphora in Eucalypt refer to different parameters. <code class="highlighter-rouge">"{}{}"</code> is a
two-argument function which concatenates strings, <code class="highlighter-rouge">_ * _</code> is a two
argument function that multiplies numbers.</p>
</blockquote>

<p>Back to:</p>

<pre><code class="language-eu">target-zones: ["a", "b", "c"] map("eu-west-1{}")
</code></pre>

<p>The whole line is a <strong>declaration</strong>. Declarations come in several
types - this one is a <strong>property declaration</strong>. A <strong>block</strong> is written
as a sequence of declarations enclosed in braces. For example:</p>

<pre><code class="language-eu">{
  w: "foo" # a string
  x: 3 # a number
  y: 22.2 # a floaty number
  z: true # the truth
}
</code></pre>

<p>(The <code class="highlighter-rouge">#</code> character introduces a comment which is ignored by Eucalypt.)</p>

<p>Unlike YAML, indentation is never significant.</p>

<p>Unlike JSON, commas are not needed to separate declarations. Instead,
the Eucalypt parser determines the declarations mainly based on the
location of colons. You can write:</p>

<pre><code class="language-eu">{ x: 1 increment negate y: 2 }
</code></pre>

<p>…and Eucalypt knows it’s two declarations.</p>

<p>Our <code class="highlighter-rouge">target-zones</code> property declaration is at the <strong>top level</strong> so is
not surrounded by braces explicitly. Nevertheless it is in a block:
the top level block, known as a <strong>unit</strong>, that is defined by the file
it is in. You can imagine the braces to be there if you like.</p>

<p>As a final point on this example, it is probably worthwhile
documenting declarations. Eucalypt offers an easy way to do that using
<strong>declaration metadata</strong> which we squeeze in between a leading
backtick and the declaration itself:</p>

<pre><code class="language-eu">` “AZs to deploy alien widgets in”
target-zones: [“a”, “b”, “c”] map(“eu-west-1{}”)
</code></pre>

<p>All sorts of things can be wedged in there, but if a string appears on
its own is interpreted as documentation.</p>

<h2 id="example-two">Example Two</h2>

<p>Let’s look at another small example:</p>

<pre><code class="language-eu">character(name): {
  resource-name: name
  created: io.epoch-time
}

prentice: character("Pirate Prentice") {
  laser-colour: "red"
}

slothrop: character("Tyrone Slothrop") {
  eye-count: 7
}
</code></pre>

<p>We’ve introduced a new type of declaration here: <code class="highlighter-rouge">base(name): ...</code>.
This is a <strong>function declaration</strong>. (Remember we saw a <strong>property
declaration</strong> earlier.)</p>

<blockquote>
  <p>Eucalypt also has <strong>operator declarations</strong> and a <strong>splice syntax</strong>
but we’ll ignore those for now. One day they will be covered in the
user guide…</p>
</blockquote>

<p>The function declaration declares a function called <code class="highlighter-rouge">character</code>, which
accepts a single parameter (<code class="highlighter-rouge">name</code>) and returns a block containing two
property declarations.</p>

<p>Functions, like everything else in Eucalypt, are declared in and live
in blocks but they are left out when output is generated, so you won’t
see them in the YAML or JSON that Eucalypt produces.</p>

<p>The braces in the definition of <code class="highlighter-rouge">character</code> are there to delimit the
resulting block - <em>not</em> to define a function body. A function that
returned a number would not need them:</p>

<pre><code class="language-eu">inc(x): x + 1 # this defines an increment function
</code></pre>

<p>…nor would any function that returns a block without using a block
literal:</p>

<pre><code class="language-eu">identity(x): x # this returns its argument, which could be a block
</code></pre>

<p>The next important ingredient in this example is <em>block catenation</em>.</p>

<p>Blocks can be treated as functions of a single parameter. When they
are applied as functions, the effect is a <em>block merge</em>.</p>

<p>We’ve already seen that functions can be applied to arguments by
concatenation.</p>

<p>So writing one block after another produces a merged block. It
contains the contents of the second block merged “on top” of the
first.</p>

<p>There is much more to be said on block merging, but for now:</p>

<p><code class="highlighter-rouge">{ a: 1 } { b: 2 }</code> evaluates to <code class="highlighter-rouge">{ a: 1 b: 2 }</code>.</p>

<p>and</p>

<p><code class="highlighter-rouge">{ a: 1 } { a: 2 }</code> evaluates to <code class="highlighter-rouge">{ a: 2 }</code>.</p>

<p>In our example, the resulting YAML would be”</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">prentice</span><span class="pi">:</span>
  <span class="na">resource-name</span><span class="pi">:</span> <span class="s">Pirate Prentice</span>
  <span class="na">created</span><span class="pi">:</span> <span class="s">1526991765</span>
  <span class="na">laser-colour</span><span class="pi">:</span> <span class="s">red</span>

<span class="na">slothrop</span><span class="pi">:</span>
  <span class="na">resource-name</span><span class="pi">:</span> <span class="s">Tyrone Slothrop</span>
  <span class="na">created</span><span class="pi">:</span> <span class="s">1526991765</span>
  <span class="na">eye-count</span><span class="pi">:</span> <span class="s">7</span>
</code></pre></div></div>

<p>As you can see, <code class="highlighter-rouge">io.epoch-time</code> evaluates to a timestamp.</p>

<p>This metadata is generated once at launch time, <em>not</em> each time the
expression is evaluated. Eucalypt the language is a pure functional
language, and there are no side-effects or non-deterministic functions
(although its command line driver can perform all sorts of
side-effects as input to the evaluation and as output from the
evaluation). For this reason, <code class="highlighter-rouge">prentice</code> and <code class="highlighter-rouge">slothrop</code> will have the
same timestamps.</p>

<p>Block merge can be a useful means of generating common content in
objects.</p>

<p>The common content can appear first as in this case, allowing it to be
overridden. Or it couple be applied second allowing it to override the
existing detail. Or a mixture of both. Many more sophisticated means
of combining block data are available too.</p>

<blockquote>
  <p>This merge is similar to the effect of <em>merge keys</em> in YAML, where a
special <code class="highlighter-rouge">&lt;&lt;</code> mapping key causes a similar merge to occur. Not all
YAML processors support this - but Eucalypt does.</p>
</blockquote>

<p>Be aware that Eucalypt has nothing like virtual functions. The
functions in scope when an expression is created are the ones that are
applied. So if you redefine an <code class="highlighter-rouge">f</code> like this, in an overriding
block…</p>

<pre><code class="language-eu">{ f(x): x+1 a: f(2) } { f(x): x-2 }
</code></pre>

<p>…the definition of <code class="highlighter-rouge">a</code> will not see it.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">a</span><span class="pi">:</span> <span class="s">3</span>
</code></pre></div></div>

<p>So block merge is only very loosely related to object oriented
inheritance. Also by default you only get a <em>shallow</em> merge - deep
merges are provided in the standard prelude and covered in the user
guide.</p>

<p>Just like we have string anaphora for turning simple strings into
string-valued functions we have block anaphora, which appear as
numbers prefixed with a leading underscore. <code class="highlighter-rouge">b: { a: _ }</code> defines a
function, <code class="highlighter-rouge">b</code>, of one parameter returning a block. <code class="highlighter-rouge">b(2)</code> (or <code class="highlighter-rouge">2 b</code>)
evaluates to <code class="highlighter-rouge">{ a: 2 }</code>. Applying a block with anaphora to another
block will evaluate the function defined rather than falling back to
block merge which is really just the default behaviour of applying a
block.</p>

<p>Eucalypt does not have a general lambda syntax (yet). If anaphora
cannot do what you want, consider using less nesting and defining
intermediate functions explicitly using function declaration syntax.</p>

<h2 id="quick-tour-of-the-command-line">Quick tour of the command line</h2>

<p>Let’s shift now to the pragmatics of using Eucalypt from the command
line.</p>

<p>On macOS you can install the <code class="highlighter-rouge">eu</code> command line tools using Homebrew
with:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew install eucalypt
</code></pre></div></div>

<p>Check the version you are running with:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>eu <span class="nt">-v</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">eu</code> is intended to be easy to use for common tasks and does its best
to allow you to say what you want succinctly. It should be easy to use
in pipelines in combination with other tools like <code class="highlighter-rouge">jq</code>.</p>

<p>By default, it runs in <strong>ergonomic</strong> mode which will make a few
assumptions in order to allow you to be a little less explicit.</p>

<p>It also pulls in user-specific declarations from <code class="highlighter-rouge">~/.eucalypt</code>. For
repeatable builds and scripted usage, it is normally more appropriate
to turn ergonomic mode <em>off</em> using the <code class="highlighter-rouge">-B (--batch-mode)</code> switch.</p>

<p>The simplest usage is to specify a Eucalypt file to evaluate and leave
the default render format (YAML) and output (standard out) alone.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> eu test.eu
</code></pre></div></div>

<p>In ergonomic mode, <code class="highlighter-rouge">eu</code> with no arguments will generally be taken to
specify that input is coming from standard in. So the above is
equivalent to:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">cat </span>test.eu | eu
</code></pre></div></div>

<p>There is a switch to control output format explicitly (<code class="highlighter-rouge">-x yaml</code>, <code class="highlighter-rouge">x
json</code>, <code class="highlighter-rouge">x toml</code>, …) but for the very common case of requiring JSON
output there is a shortcut:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> eu test.eu <span class="nt">-j</span>
</code></pre></div></div>

<p>You can, of course, redirect standard output to a file but if you
specify the output file explicitly (with <code class="highlighter-rouge">-o</code>), <code class="highlighter-rouge">eu</code> will infer the
output format from the extension:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> eu test.eu <span class="nt">-o</span> output.json <span class="c"># broadly equivalent to eu test.eu -j &gt; output.json</span>
</code></pre></div></div>

<p>Small snippets of Eucalypt can be passed in directly using the <code class="highlighter-rouge">-e
(--evaluate)</code> switch.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> eu <span class="nt">-e</span> <span class="s1">'{ a: 8 * 8 }'</span>
</code></pre></div></div>

<p>The fact that Eucalypt makes relatively infrequent use of single
quotes makes this usage straightforward for most shells.</p>

<p>By default, <code class="highlighter-rouge">eu</code> evaluates the entirety of the loaded source and uses
all of it to render the result, leaving out any function values and
other non-renderable content.</p>

<p>It is possible though to select more targeted content for output by
several means:</p>

<ol>
  <li>A declaration in the source may be identified as the <strong>main</strong> target
using the <code class="highlighter-rouge">:main</code> declaration metadata</li>
  <li><strong>targets</strong> may be named using the <code class="highlighter-rouge">:target</code> declaration metadata
and those targets can then be specified using the <code class="highlighter-rouge">-t (--target)</code>
option to <code class="highlighter-rouge">eu</code></li>
  <li>The <code class="highlighter-rouge">-e (--evaluate)</code> option can be used in addition to other
source file(s) to identify an expression to be rendered (e.g. <code class="highlighter-rouge">eu
test.eu -e x.y.z</code>)</li>
</ol>

<p>In passing, we should note that <code class="highlighter-rouge">eu</code>’s ability to read JSON and YAML
natively combined with the last options give a simple way to pick
values out of structured data:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> aws s3api list-buckets | eu <span class="nt">-e</span> <span class="s1">'Buckets map(lookup(:Name))'</span>
</code></pre></div></div>

<p>There is much more to this story. For instance <code class="highlighter-rouge">eu</code> can:</p>

<ul>
  <li>accept several inputs to make definitions in earlier inputs
available to subsequent inputs <code class="highlighter-rouge">eu test1.eu test2.eu test3.eu</code></li>
  <li>accept YAML and JSON files as pure data to be merged in: <code class="highlighter-rouge">eu
data.yaml tools.eu</code></li>
  <li>accept YAML or JSON annotated with Eucalypt to execute: <code class="highlighter-rouge">eu
data.yaml</code></li>
  <li>override the default extensions: <code class="highlighter-rouge">eu yaml@info.txt</code></li>
  <li>automatically use <code class="highlighter-rouge">Eufile</code> files in the current folder hierarchy</li>
</ul>

<p>The fabled user guide will contain more on all these usages.</p>



      </section>

    </div>

    
  </body>
</html>

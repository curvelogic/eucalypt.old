# -*- mode: conf -*-

### Running `eu`

# `eu -x xml simple.ont types`
#
# ```xml
# <types>
#   <count>12345</count>
# </types>
# ```

# The command line follows a few general principles:

# - URLs throughout; wherever a filename may be supplied, so may a
# URL - Any number of input files may be provided; by default these
# should be `.euc` files but the command line program will interpret
# other input files as appropriate and create blocks for them. The end
# of a set of input files (and the start of general command line
# arguments which are passed through to the eucalypt script is
# signalled by a --):

# `eu intro.eu data.json data.yml -- -blah -v3`
#
# The name of the block created for any data file may be controlled
# too by prefixing `name=`:
#
# `eu trans.eu in=http://blah/input.json`

# Eucalypt can be used in various ways; firstly as a front end to
# other formats for configuration, either outputing configuration
# files for other programs or piping directly into them.

# `eu -x yaml simple.eu builtins.happies`

# `eu -x json simple.eu laziness.ten-exes`

# `eu -x edn simple.eu '~' | echo`

# -x (export) can be used to control output format - default is json.

# -r (render) can be used to render source level
# documentation.

# This file can be rendered to markdown using:
# `eu -r markdown intro.euc`

# For tedious and frustrating configuration formats like
# CloudFormation JSON for instance this can vastly increase the
# expressiveness and maintainability of the configuration. (But see
# terraform for a better solution to the CloudFormation problem.)

# `env | eu -x xml --input-kv simple.eu environment.echo(input)`

` { if: :environment }
environment: {
  echo: map("ENV {k} is {v}\n")
}

#
# Other input formats --input-json, --input-xml, --input-yaml,
# --input-raw
#
# These input filters transform the input into eu block structures
# that can be easily accessed in eucalypt.

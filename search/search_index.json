{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"eucalypt is a tool, and a little language, for generating and transforming structured data formats like YAML and JSON. If you use text-based templating to process these formats or you pipe this these formats through several different tools or build steps, eucalypt should be able to help you generate your output more cleanly and with fewer cognitive somersaults. eucalypt is a purely functional language that can be used quickly and easily from the command line. It has the following features: a concise native syntax that allows you to define data, functions, and operators a simple embedding into YAML files to support in-place manipulation of the data (a la templating) facilities for manipulating blocks (think JSON objects, YAML mappings) facilities for manipulating text including string interpolation and regular expressions an ergonomic command line interface and access to environment variables metadata annotations and numerous extension points It can currently read YAML, JSON, TOML and eucalypt syntax and export YAML, JSON or text. If you're generating or processing YAML or JSON, you should give it a try. Warning eucalypt is in an early phase of development and highly subject to change. Not all features are fully implemented. A lightning tour A few micro-examples should help give a flavour of eucalypt 's native syntax. If you want to try out the tool, see Getting Started . Example 1 Here is a simple one: target-zones: [ a , b , c ] map( eu-west-1{} ) You can put this in a file named test.eu and run it with eu test.eu . This generates the following YAML: target-zones: - eu-west-1a - eu-west-1b - eu-west-1c Although we're looking at the native eucalypt syntax here, this example could just as easily be embedded directly in a YAML file using the !eu tag. Pop the following in a test.yaml file and process it with eu test.yaml . You'll get the same result. target-zones: !eu [ a , b , c ] map( eu-west-1{} ) First, this example illustrates how we apply transformations like map simply by concatenation. In fact this is nothing more than a function call but this feature allows us to write things in an order which makes the processing clear. In this example, map is just a function of two parameters. Its first argument is provided in parentheses and its second argument is the value of what came before. Note Users of languages like Elixir or OCaml may recognise an implicit | operator here. Clojure users may see an invisible threading macro. Note that writing elements next to each other like this gives you the reverse of what you might expect in Haskell or OCaml or Lisp: we write x f not f x . There is a lot of freedom in eucalypt to express ideas in different ways and develop colorful and cryptic expressions. In a larger or more ambitious language this could be viewed as rope to hang yourself with. You will be careful won't you? The string template, \"eu-west-1{}\" actually defines a function of one argument that returns a string. The key ingredients here are: the interpolation syntax \"{...}\" which allows values to be inserted into the string the (hidden) use of numeric anaphora in the interpolation syntax ( {0} , {1} , {2} , ...) which cause the string to define a function, not just sequence of characters the use of the unnumbered anaphor ( {} ) which is numbered automatically for us, so in this case, {} is a convenient synonym for {0} - the first argument Note Anaphora crop up in various contexts in eucalypt and are generally preferable to the full generality of lambdas. If the idea is too complex to be expressed with anaphora, it should generally be explicitly named. So: a: 42 The answer is {0} renders as a: The answer is 42 eucalypt also has expression anaphora which use underscores - x: _0 + _1 . Note Users of Groovy or Kotlin may recognise an equivalent of the it parameter. Seasoned Lisp hackers are familiar with anaphoric macros. Clojure users will recognise the % , %1 , %2 forms usable in #(...) contexts. Unlike Clojure's % repeated uses of unnumbered anaphora in eucalypt refer to different parameters. \"{}{}\" is a two-argument function which concatenates strings, _ * _ is a two argument function that multiplies numbers. Back to: target-zones: [ a , b , c ] map( eu-west-1{} ) The whole line is a declaration . Declarations come in several types - this one is a property declaration . A block is written as a sequence of declarations enclosed in braces. For example: { w: foo # a string x: 3 # a number y: 22.2 # a floaty number z: true # the truth } (The # character introduces a comment which is ignored by eucalypt .) Unlike YAML, indentation is never significant. Unlike JSON, commas are not needed to separate declarations. Instead, the eucalypt parser determines the declarations mainly based on the location of colons. You can write: { x: 1 increment negate y: 2 } ...and eucalypt knows it's two declarations. Our target-zones property declaration is at the top level so is not surrounded by braces explicitly. Nevertheless it is in a block: the top level block, known as a unit , that is defined by the file it is in. You can imagine the braces to be there if you like. As a final point on this example, it is probably worthwhile documenting declarations. eucalypt offers an easy way to do that using declaration metadata which we squeeze in between a leading backtick and the declaration itself: ` \u201cAZs to deploy alien widgets in\u201d target-zones: [\u201ca\u201d, \u201cb\u201d, \u201cc\u201d] map(\u201ceu-west-1{}\u201d) All sorts of things can be wedged in there, but if a string appears on its own is interpreted as documentation. Example 2 Let's look at another small example: character(name): { resource-name: name created: io.epoch-time } prentice: character( Pirate Prentice ) { laser-colour: red } slothrop: character( Tyrone Slothrop ) { eye-count: 7 } We've introduced a new type of declaration here: base(name): ... . This is a function declaration . (Remember we saw a property declaration earlier.) Note eucalypt also has operator declarations and a splice syntax but we'll ignore those for now. One day they will be covered in the user guide... The function declaration declares a function called character , which accepts a single parameter ( name ) and returns a block containing two property declarations. Functions, like everything else in eucalypt , are declared in and live in blocks but they are left out when output is generated, so you won't see them in the YAML or JSON that eucalypt produces. The braces in the definition of character are there to delimit the resulting block - not to define a function body. A function that returned a number would not need them: inc(x): x + 1 # this defines an increment function ...nor would any function that returns a block without using a block literal: identity(x): x # this returns its argument, which could be a block The next important ingredient in this example is block catenation . Blocks can be treated as functions of a single parameter. When they are applied as functions, the effect is a block merge . We've already seen that functions can be applied to arguments by concatenation. So writing one block after another produces a merged block. It contains the contents of the second block merged \"on top\" of the first. There is much more to be said on block merging, but for now: { a: 1 } { b: 2 } evaluates to { a: 1 b: 2 } . and { a: 1 } { a: 2 } evaluates to { a: 2 } . In our example, the resulting YAML would be\" prentice: resource-name: Pirate Prentice created: 1526991765 laser-colour: red slothrop: resource-name: Tyrone Slothrop created: 1526991765 eye-count: 7 As you can see, io.epoch-time evaluates to a timestamp. This metadata is generated once at launch time, not each time the expression is evaluated. eucalypt the language is a pure functional language, and there are no side-effects or non-deterministic functions (although its command line driver can perform all sorts of side-effects as input to the evaluation and as output from the evaluation). For this reason, prentice and slothrop will have the same timestamps. Block merge can be a useful means of generating common content in objects. The common content can appear first as in this case, allowing it to be overridden. Or it couple be applied second allowing it to override the existing detail. Or a mixture of both. Many more sophisticated means of combining block data are available too. Note This merge is similar to the effect of merge keys in YAML, where a special mapping key causes a similar merge to occur. Not all YAML processors support this - but eucalypt does. Be aware that eucalypt has nothing like virtual functions. The functions in scope when an expression is created are the ones that are applied. So if you redefine an f like this, in an overriding block... { f(x): x+1 a: f(2) } { f(x): x-2 } ...the definition of a will not see it. a: 3 So block merge is only very loosely related to object oriented inheritance. Also by default you only get a shallow merge - deep merges are provided in the standard prelude and covered in the user guide. Just like we have string anaphora for turning simple strings into string-valued functions we have block anaphora, which appear as numbers prefixed with a leading underscore. b: { a: _ } defines a function, b , of one parameter returning a block. b(2) (or 2 b ) evaluates to { a: 2 } . Applying a block with anaphora to another block will evaluate the function defined rather than falling back to block merge which is really just the default behaviour of applying a block. eucalypt does not have a general lambda syntax (yet). If anaphora cannot do what you want, consider using less nesting and defining intermediate functions explicitly using function declaration syntax. Quick tour of the command line Let's shift now to the pragmatics of using eucalypt from the command line. On macOS you can install the eu command line tools using Homebrew with: brew install eucalypt Check the version you are running with: eu -v eu is intended to be easy to use for common tasks and does its best to allow you to say what you want succinctly. It should be easy to use in pipelines in combination with other tools like jq . By default, it runs in ergonomic mode which will make a few assumptions in order to allow you to be a little less explicit. It also pulls in user-specific declarations from ~/.eucalypt . For repeatable builds and scripted usage, it is normally more appropriate to turn ergonomic mode off using the -B (--batch-mode) switch. The simplest usage is to specify a eucalypt file to evaluate and leave the default render format (YAML) and output (standard out) alone. eu test.eu In ergonomic mode, eu with no arguments will generally be taken to specify that input is coming from standard in. So the above is equivalent to: cat test.eu | eu There is a switch to control output format explicitly ( -x yaml , x json , x toml , ...) but for the very common case of requiring JSON output there is a shortcut: eu test.eu -j You can, of course, redirect standard output to a file but if you specify the output file explicitly (with -o ), eu will infer the output format from the extension: eu test.eu -o output.json # broadly equivalent to eu test.eu -j output.json Small snippets of eucalypt can be passed in directly using the -e (--evaluate) switch. eu -e '{ a: 8 * 8 }' The fact that eucalypt makes relatively infrequent use of single quotes makes this usage straightforward for most shells. By default, eu evaluates the entirety of the loaded source and uses all of it to render the result, leaving out any function values and other non-renderable content. It is possible though to select more targeted content for output by several means: A declaration in the source may be identified as the main target using the :main declaration metadata targets may be named using the :target declaration metadata and those targets can then be specified using the -t (--target) option to eu The -e (--evaluate) option can be used in addition to other source file(s) to identify an expression to be rendered (e.g. eu test.eu -e x.y.z ) In passing, we should note that eu 's ability to read JSON and YAML natively combined with the last options give a simple way to pick values out of structured data: aws s3api list-buckets | eu -e 'Buckets map(lookup(:Name))' There is much more to this story. For instance eu can: accept several inputs to make definitions in earlier inputs available to subsequent inputs eu test1.eu test2.eu test3.eu accept YAML and JSON files as pure data to be merged in: eu data.yaml tools.eu accept YAML or JSON annotated with eucalypt to execute: eu data.yaml override the default extensions: eu yaml@info.txt automatically use Eufile files in the current folder hierarchy The fabled user guide will contain more on all these usages.","title":"Home"},{"location":"#a-lightning-tour","text":"A few micro-examples should help give a flavour of eucalypt 's native syntax. If you want to try out the tool, see Getting Started .","title":"A lightning tour"},{"location":"#example-1","text":"Here is a simple one: target-zones: [ a , b , c ] map( eu-west-1{} ) You can put this in a file named test.eu and run it with eu test.eu . This generates the following YAML: target-zones: - eu-west-1a - eu-west-1b - eu-west-1c Although we're looking at the native eucalypt syntax here, this example could just as easily be embedded directly in a YAML file using the !eu tag. Pop the following in a test.yaml file and process it with eu test.yaml . You'll get the same result. target-zones: !eu [ a , b , c ] map( eu-west-1{} ) First, this example illustrates how we apply transformations like map simply by concatenation. In fact this is nothing more than a function call but this feature allows us to write things in an order which makes the processing clear. In this example, map is just a function of two parameters. Its first argument is provided in parentheses and its second argument is the value of what came before. Note Users of languages like Elixir or OCaml may recognise an implicit | operator here. Clojure users may see an invisible threading macro. Note that writing elements next to each other like this gives you the reverse of what you might expect in Haskell or OCaml or Lisp: we write x f not f x . There is a lot of freedom in eucalypt to express ideas in different ways and develop colorful and cryptic expressions. In a larger or more ambitious language this could be viewed as rope to hang yourself with. You will be careful won't you? The string template, \"eu-west-1{}\" actually defines a function of one argument that returns a string. The key ingredients here are: the interpolation syntax \"{...}\" which allows values to be inserted into the string the (hidden) use of numeric anaphora in the interpolation syntax ( {0} , {1} , {2} , ...) which cause the string to define a function, not just sequence of characters the use of the unnumbered anaphor ( {} ) which is numbered automatically for us, so in this case, {} is a convenient synonym for {0} - the first argument Note Anaphora crop up in various contexts in eucalypt and are generally preferable to the full generality of lambdas. If the idea is too complex to be expressed with anaphora, it should generally be explicitly named. So: a: 42 The answer is {0} renders as a: The answer is 42 eucalypt also has expression anaphora which use underscores - x: _0 + _1 . Note Users of Groovy or Kotlin may recognise an equivalent of the it parameter. Seasoned Lisp hackers are familiar with anaphoric macros. Clojure users will recognise the % , %1 , %2 forms usable in #(...) contexts. Unlike Clojure's % repeated uses of unnumbered anaphora in eucalypt refer to different parameters. \"{}{}\" is a two-argument function which concatenates strings, _ * _ is a two argument function that multiplies numbers. Back to: target-zones: [ a , b , c ] map( eu-west-1{} ) The whole line is a declaration . Declarations come in several types - this one is a property declaration . A block is written as a sequence of declarations enclosed in braces. For example: { w: foo # a string x: 3 # a number y: 22.2 # a floaty number z: true # the truth } (The # character introduces a comment which is ignored by eucalypt .) Unlike YAML, indentation is never significant. Unlike JSON, commas are not needed to separate declarations. Instead, the eucalypt parser determines the declarations mainly based on the location of colons. You can write: { x: 1 increment negate y: 2 } ...and eucalypt knows it's two declarations. Our target-zones property declaration is at the top level so is not surrounded by braces explicitly. Nevertheless it is in a block: the top level block, known as a unit , that is defined by the file it is in. You can imagine the braces to be there if you like. As a final point on this example, it is probably worthwhile documenting declarations. eucalypt offers an easy way to do that using declaration metadata which we squeeze in between a leading backtick and the declaration itself: ` \u201cAZs to deploy alien widgets in\u201d target-zones: [\u201ca\u201d, \u201cb\u201d, \u201cc\u201d] map(\u201ceu-west-1{}\u201d) All sorts of things can be wedged in there, but if a string appears on its own is interpreted as documentation.","title":"Example 1"},{"location":"#example-2","text":"Let's look at another small example: character(name): { resource-name: name created: io.epoch-time } prentice: character( Pirate Prentice ) { laser-colour: red } slothrop: character( Tyrone Slothrop ) { eye-count: 7 } We've introduced a new type of declaration here: base(name): ... . This is a function declaration . (Remember we saw a property declaration earlier.) Note eucalypt also has operator declarations and a splice syntax but we'll ignore those for now. One day they will be covered in the user guide... The function declaration declares a function called character , which accepts a single parameter ( name ) and returns a block containing two property declarations. Functions, like everything else in eucalypt , are declared in and live in blocks but they are left out when output is generated, so you won't see them in the YAML or JSON that eucalypt produces. The braces in the definition of character are there to delimit the resulting block - not to define a function body. A function that returned a number would not need them: inc(x): x + 1 # this defines an increment function ...nor would any function that returns a block without using a block literal: identity(x): x # this returns its argument, which could be a block The next important ingredient in this example is block catenation . Blocks can be treated as functions of a single parameter. When they are applied as functions, the effect is a block merge . We've already seen that functions can be applied to arguments by concatenation. So writing one block after another produces a merged block. It contains the contents of the second block merged \"on top\" of the first. There is much more to be said on block merging, but for now: { a: 1 } { b: 2 } evaluates to { a: 1 b: 2 } . and { a: 1 } { a: 2 } evaluates to { a: 2 } . In our example, the resulting YAML would be\" prentice: resource-name: Pirate Prentice created: 1526991765 laser-colour: red slothrop: resource-name: Tyrone Slothrop created: 1526991765 eye-count: 7 As you can see, io.epoch-time evaluates to a timestamp. This metadata is generated once at launch time, not each time the expression is evaluated. eucalypt the language is a pure functional language, and there are no side-effects or non-deterministic functions (although its command line driver can perform all sorts of side-effects as input to the evaluation and as output from the evaluation). For this reason, prentice and slothrop will have the same timestamps. Block merge can be a useful means of generating common content in objects. The common content can appear first as in this case, allowing it to be overridden. Or it couple be applied second allowing it to override the existing detail. Or a mixture of both. Many more sophisticated means of combining block data are available too. Note This merge is similar to the effect of merge keys in YAML, where a special mapping key causes a similar merge to occur. Not all YAML processors support this - but eucalypt does. Be aware that eucalypt has nothing like virtual functions. The functions in scope when an expression is created are the ones that are applied. So if you redefine an f like this, in an overriding block... { f(x): x+1 a: f(2) } { f(x): x-2 } ...the definition of a will not see it. a: 3 So block merge is only very loosely related to object oriented inheritance. Also by default you only get a shallow merge - deep merges are provided in the standard prelude and covered in the user guide. Just like we have string anaphora for turning simple strings into string-valued functions we have block anaphora, which appear as numbers prefixed with a leading underscore. b: { a: _ } defines a function, b , of one parameter returning a block. b(2) (or 2 b ) evaluates to { a: 2 } . Applying a block with anaphora to another block will evaluate the function defined rather than falling back to block merge which is really just the default behaviour of applying a block. eucalypt does not have a general lambda syntax (yet). If anaphora cannot do what you want, consider using less nesting and defining intermediate functions explicitly using function declaration syntax.","title":"Example 2"},{"location":"#quick-tour-of-the-command-line","text":"Let's shift now to the pragmatics of using eucalypt from the command line. On macOS you can install the eu command line tools using Homebrew with: brew install eucalypt Check the version you are running with: eu -v eu is intended to be easy to use for common tasks and does its best to allow you to say what you want succinctly. It should be easy to use in pipelines in combination with other tools like jq . By default, it runs in ergonomic mode which will make a few assumptions in order to allow you to be a little less explicit. It also pulls in user-specific declarations from ~/.eucalypt . For repeatable builds and scripted usage, it is normally more appropriate to turn ergonomic mode off using the -B (--batch-mode) switch. The simplest usage is to specify a eucalypt file to evaluate and leave the default render format (YAML) and output (standard out) alone. eu test.eu In ergonomic mode, eu with no arguments will generally be taken to specify that input is coming from standard in. So the above is equivalent to: cat test.eu | eu There is a switch to control output format explicitly ( -x yaml , x json , x toml , ...) but for the very common case of requiring JSON output there is a shortcut: eu test.eu -j You can, of course, redirect standard output to a file but if you specify the output file explicitly (with -o ), eu will infer the output format from the extension: eu test.eu -o output.json # broadly equivalent to eu test.eu -j output.json Small snippets of eucalypt can be passed in directly using the -e (--evaluate) switch. eu -e '{ a: 8 * 8 }' The fact that eucalypt makes relatively infrequent use of single quotes makes this usage straightforward for most shells. By default, eu evaluates the entirety of the loaded source and uses all of it to render the result, leaving out any function values and other non-renderable content. It is possible though to select more targeted content for output by several means: A declaration in the source may be identified as the main target using the :main declaration metadata targets may be named using the :target declaration metadata and those targets can then be specified using the -t (--target) option to eu The -e (--evaluate) option can be used in addition to other source file(s) to identify an expression to be rendered (e.g. eu test.eu -e x.y.z ) In passing, we should note that eu 's ability to read JSON and YAML natively combined with the last options give a simple way to pick values out of structured data: aws s3api list-buckets | eu -e 'Buckets map(lookup(:Name))' There is much more to this story. For instance eu can: accept several inputs to make definitions in earlier inputs available to subsequent inputs eu test1.eu test2.eu test3.eu accept YAML and JSON files as pure data to be merged in: eu data.yaml tools.eu accept YAML or JSON annotated with eucalypt to execute: eu data.yaml override the default extensions: eu yaml@info.txt automatically use Eufile files in the current folder hierarchy The fabled user guide will contain more on all these usages.","title":"Quick tour of the command line"},{"location":"command-line/","text":"eu command line Eucalypt is available as a command line tool, eu , which reads inputs and writes outputs. Everything it does in between is purely functional and there is no mutable state. It is intended to be simple to use in unix pipelines. eu --version # shows the current eu version eu --help # lists command line options Inputs Files / stdin eu can read several inputs, specified by command line arguments. Inputs specify text data from: files stdin internal resources (ignored for now) (in future) HTTPS URLS or Git refs ...of which the first two are the common case. In the simplest case, file inputs are specified by file name, stdin is specified by - . So eu a.yaml - b.eu ...will read input from a.yaml , stdin and b.eu . Each will be read into eucalypt 's core representation and merged before output is rendered. Input format Inputs must be one of the formats that eucalypt supports, which at present, are: YAML JSON TOML Usually the format is inferred from file extension but it can be overridden on an input by input basis using a format@ prefix. For instance: eu yaml@a.txt json@- yaml@b.txt ...will read YAML from a.txt , JSON from stdin and YAML from b.txt . Named inputs Finally inputs can be named using a name= prefix. This alters the way that data is merged by making the contents of an input available in a block or list with the specified name, instead of at the top level. Suppose we have two inputs: foo: bar x: 42 then eu a.yaml b.eu would generate: foo: bar x: 42 but eu data=a.yaml b.eu would generate: data: foo: bar x: 42 This can be useful for various reasons, particularly when: the form of the input's content is not known in advance the input's content is a list rather than a block Full input syntax The full input syntax is therefore: [name=][format@][URL/file] This applies at the command line and also when specifying imports in .eu files. stdin defaulting When no inputs are specified and eu is being used in a pipeline, it will accept input from stdin by default, making it easy to pipe JSON or YAML from other tools into eu. For example, this takes JSON from the aws CLI and formats it as YAML to stdout. aws s3-api list-buckets | eu How inputs are merged When several inputs are listed, names from earlier inputs become available to later inputs, but the content that will be rendered is that of the final input. The common use case is a final input which contains logic to inspect or process data provided by the previous inputs (potentially coming in from previous processing on stdin). If you want to render contents of earlier inputs verbatim, you need a named input to provide a name for that content which you can then use. Outputs In the current version, eu can only generate one output. Output format Output is rendered as YAML by default. Other formats can be specified using the -x command line option: eu -x json # for JSON eu -x text # for plain text JSON is such a common case that there is a shortcut: -j . Output targets By default, eucalypt renders all the content of the final input to output. There are various ways to override this. First, :target metadata can be specified in the final input to identify different parts for potential export. To list the targets found in the specified inputs, use the -t flag. eu -l ...and a particular target can be selected for render using -t . eu -t my-target If there is a target called \"main\" it will be used by default unless another target is specified. Evaluands In addition to inputs, an evaluand can be specified at the command line. This is a eucalypt expression which has access to all names defined in the inputs and replaces the input body or targets as the data to export. It can be used to select content or derive values from data in the inputs: $ aws s3api list-buckets | eu -e 'Buckets map(lookup(:CreationDate)) head' 2016-12-25T14:22:30.000Z ...or just to test out short expressions or command line features: $ eu -e '{a: 1 b: 2 * 2}' -j { a : 1, b : 4} Suppressing prelude A standard prelude containing many functions and operators is automatically prepended to the input list. This can be suppressed using -Q if it is not required or if you would like to provide an alternative. Warning Many very basic facilities - like the definition of true and false and if - are provided by the prelude so suppressing it leaves a very bare environment. Debugging eu has a variety of command line switches for dumping out internal representations or tracing execution. eu --help lists them all.","title":"Command Line"},{"location":"command-line/#eu-command-line","text":"Eucalypt is available as a command line tool, eu , which reads inputs and writes outputs. Everything it does in between is purely functional and there is no mutable state. It is intended to be simple to use in unix pipelines. eu --version # shows the current eu version eu --help # lists command line options","title":"eu command line"},{"location":"command-line/#inputs","text":"","title":"Inputs"},{"location":"command-line/#files-stdin","text":"eu can read several inputs, specified by command line arguments. Inputs specify text data from: files stdin internal resources (ignored for now) (in future) HTTPS URLS or Git refs ...of which the first two are the common case. In the simplest case, file inputs are specified by file name, stdin is specified by - . So eu a.yaml - b.eu ...will read input from a.yaml , stdin and b.eu . Each will be read into eucalypt 's core representation and merged before output is rendered.","title":"Files / stdin"},{"location":"command-line/#input-format","text":"Inputs must be one of the formats that eucalypt supports, which at present, are: YAML JSON TOML Usually the format is inferred from file extension but it can be overridden on an input by input basis using a format@ prefix. For instance: eu yaml@a.txt json@- yaml@b.txt ...will read YAML from a.txt , JSON from stdin and YAML from b.txt .","title":"Input format"},{"location":"command-line/#named-inputs","text":"Finally inputs can be named using a name= prefix. This alters the way that data is merged by making the contents of an input available in a block or list with the specified name, instead of at the top level. Suppose we have two inputs: foo: bar x: 42 then eu a.yaml b.eu would generate: foo: bar x: 42 but eu data=a.yaml b.eu would generate: data: foo: bar x: 42 This can be useful for various reasons, particularly when: the form of the input's content is not known in advance the input's content is a list rather than a block","title":"Named inputs"},{"location":"command-line/#full-input-syntax","text":"The full input syntax is therefore: [name=][format@][URL/file] This applies at the command line and also when specifying imports in .eu files.","title":"Full input syntax"},{"location":"command-line/#stdin-defaulting","text":"When no inputs are specified and eu is being used in a pipeline, it will accept input from stdin by default, making it easy to pipe JSON or YAML from other tools into eu. For example, this takes JSON from the aws CLI and formats it as YAML to stdout. aws s3-api list-buckets | eu","title":"stdin defaulting"},{"location":"command-line/#how-inputs-are-merged","text":"When several inputs are listed, names from earlier inputs become available to later inputs, but the content that will be rendered is that of the final input. The common use case is a final input which contains logic to inspect or process data provided by the previous inputs (potentially coming in from previous processing on stdin). If you want to render contents of earlier inputs verbatim, you need a named input to provide a name for that content which you can then use.","title":"How inputs are merged"},{"location":"command-line/#outputs","text":"In the current version, eu can only generate one output.","title":"Outputs"},{"location":"command-line/#output-format","text":"Output is rendered as YAML by default. Other formats can be specified using the -x command line option: eu -x json # for JSON eu -x text # for plain text JSON is such a common case that there is a shortcut: -j .","title":"Output format"},{"location":"command-line/#output-targets","text":"By default, eucalypt renders all the content of the final input to output. There are various ways to override this. First, :target metadata can be specified in the final input to identify different parts for potential export. To list the targets found in the specified inputs, use the -t flag. eu -l ...and a particular target can be selected for render using -t . eu -t my-target If there is a target called \"main\" it will be used by default unless another target is specified.","title":"Output targets"},{"location":"command-line/#evaluands","text":"In addition to inputs, an evaluand can be specified at the command line. This is a eucalypt expression which has access to all names defined in the inputs and replaces the input body or targets as the data to export. It can be used to select content or derive values from data in the inputs: $ aws s3api list-buckets | eu -e 'Buckets map(lookup(:CreationDate)) head' 2016-12-25T14:22:30.000Z ...or just to test out short expressions or command line features: $ eu -e '{a: 1 b: 2 * 2}' -j { a : 1, b : 4}","title":"Evaluands"},{"location":"command-line/#suppressing-prelude","text":"A standard prelude containing many functions and operators is automatically prepended to the input list. This can be suppressed using -Q if it is not required or if you would like to provide an alternative. Warning Many very basic facilities - like the definition of true and false and if - are provided by the prelude so suppressing it leaves a very bare environment.","title":"Suppressing prelude"},{"location":"command-line/#debugging","text":"eu has a variety of command line switches for dumping out internal representations or tracing execution. eu --help lists them all.","title":"Debugging"},{"location":"getting-started/","text":"Installation The current implementation of eucalypt is available in the eucalypt-hs project and can be installed as follows. On macOS via Homebrew If you use homebrew, you can install using brew install curvelogic/homebrew-tap/eucalypt On Linux x86_64 binaries built in CI are available on the releases page From source You will need stack (which can be found in Homebrew as haskell-stack ). Build and install should be as simple as: stack install Testing your installation eu --version ...prints the version. eu --help ...shows command line help.","title":"Getting Started"},{"location":"getting-started/#installation","text":"The current implementation of eucalypt is available in the eucalypt-hs project and can be installed as follows.","title":"Installation"},{"location":"getting-started/#on-macos-via-homebrew","text":"If you use homebrew, you can install using brew install curvelogic/homebrew-tap/eucalypt","title":"On macOS via Homebrew"},{"location":"getting-started/#on-linux","text":"x86_64 binaries built in CI are available on the releases page","title":"On Linux"},{"location":"getting-started/#from-source","text":"You will need stack (which can be found in Homebrew as haskell-stack ). Build and install should be as simple as: stack install","title":"From source"},{"location":"getting-started/#testing-your-installation","text":"eu --version ...prints the version. eu --help ...shows command line help.","title":"Testing your installation"},{"location":"philosophy-lang/","text":"eucalypt (the language) eucalypt , the language, is unorthodox in many respects - probably moreso than you might realise on first acquaintance. Many people have deep-seated and inflexible opinions about programming languages and language design 1 and will likely find something in here that they have a kneejerk reaction against. However, the design is not unprincipled and, while it is experimental in some respects, I believe it's internally consistent. Several aspects of the design and the aesthetic are driven by the primary use case. Maybe by exploring some of the inspiration and philosophy behind the language itself, I can head off potential criticism. Accept crypticality for minimal intrusion eucalypt is first and foremost a tool , rather than a language. It is intended to replace generation and transformation processes on semi-structured data formats. Many or most uses of eucalypt the language should just be simple one-liner tags in YAML files, or maybe eucalypt files that are predominantly data rather than manipulation. The eucalypt language is the depth behind these one-liners that allows eucalypt to accommodate increasingly ambitious use cases without breaking the paradigm and reaching for a general purpose scripting language. 2 The pre-eminence of one-liners and small annotations and \"logic mark-up\", means that eucalypt often favours concise and cryptic over wordy and transparent. This is a controversial approach. eucalypt logic should \"get out of the way\" of the data. Templating is attractive precisely because the generating source looks very like the result. Template tags are often short (with \"cryptic\" delimiters - {{}} , %= % , [| ] ...) because these are \"marking up\" the data which is the main event. At the same time, the tags are often \"noisy\" or visually disruptive to ensure they cannot be ignored. eucalypt via operator and bracket definitions, picks and chooseS from a similar palette of expressive effects to try and be a sympathetic cohabitee with its accompanying data. There are many cases where it makes sense to resist offering an incomplete understanding in favour of demanding full understanding. For example, it is spurious to say that bind(x, f) gives more understanding of what is going on than x = f - unless you understand the monad abstraction and the role of bind in it, you gain nothing from the ideas that the word bind conveys when trying to understand program text. eucalypt just plain ignores the notion that program text should be readable as English text. This (well motivated) idea has made a resurgence in recent years through the back door of internal DSLs and \"fluent\" Java interfaces 3 . There is much merit in languages supple enough to allow the APIs to approach the natural means of expression of the problem domain. However, problem domains frequently have their own technical jargon and notation which suit their purpose better than natural language so it cuts both ways. Program text should be approachable by its target audience but that does not mean it should make no demands of its target audience. These stances lead directly to several slightly esoteric aspects of eucalypt that may be obnoxious to some: eucalypt tends to be operator-heavy. Operators are concise (if cryptic) and the full range of unicode is available to call upon. Using operators keeps custom logic visually out of the way of the data whilst also signposting it to attract closer attention. eucalypt lets you define your own operators and specify their precedence and associativity (which are applied at a relatively late stage in the evaluation pipeline - operator soup persists through the initial parse). There are no ternary operators. For absolute minimal intrusion, merely the act of placing elements next to each other (\"catenation\"), x f , is meaningful in eucalypt . By default this is pipeline-order function application, but blocks and lists can be applied as functions to make common transformations, like block merge, very succinct. For even more power, eucalypt lets you alter the meaning of concatenation via idiot brackets 4 . This is inspired by the idiom brackets that can be used to express applicative styles in functional programming 5 . These also provide an acceptable proxy for ternary and other operators too. An equivalent generalisation of eucalypt block syntax to provide a capability similar to Haskell's do notation might follow. Cohabitation of code and data Just like templates, eucalypt source (or eucalypt -tagged YAML or JSON) should be almost entirely data. The idea behind eucalypt is to adopt the basic maps-and-arrays organisation philosophy of these data formats but make the data active - allowing lambdas to live in and amongst it and operate on it and allowing the data to express dispositions towards its environment by addition of metadata that controls import, export, and execution preferences. eucalypt therefore collapses the separation of code and data to some degree. You can run eu against a mixture of YAML, JSON and eucalypt files and all the data and logic appears there together in the same namespace hierarchy. The namespace hierarchy just is the data. However, code and data aren't unified in the sense of Lisp for instance. eucalypt is not homoiconic. The relationship is more like cohabitation; code lives in amongst the data it operates on but is stripped out before export. Nevertheless eucalypt is heavily inspired by Lisp and aims for a similar fluidity though: lazy evaluation (encompassing uses of Lisp macros which control evaluation order - if is) economical syntax and syntactic reinterpretability (idiot brackets) Simplicity eucalypt values simplicity in the sense of fewer moving parts (and therefore, hopefully, fewer things to go wrong). It values ease of use in the sense of offering a rich and powerful toolkit. You may not think it achieves either. eucalypt values familiarity more in the \"shallower\" parts of the language where it only requires a couple of mental leaps for the average programmer in these areas - (ab)use of catenation being the key one. However, eucalypt shouldn't be ashamed of its dusty corners. Dusty corners are areas where novices and experts alike can get trapped and lose time but they're also rich seams for experimentation, innovation and discovery 6 . If you have to venture too far off-piste to find what you need, we'll find a way to bring it onto the nursery slopes but we won't close off the mountain. Footnotes ...often a result of underfamiliarity with the alternatives. For some reason, I think of this rather like the historical passages in The Lord of the Rings; they give a tremendous sense of the depth of the world, that everywhere you look there is a rich culture and background staring back at you. You trust that it's all coherent and all there if you need it but are generally happy to be led through the main narrative over the surface of this rich mythology. Actually the key benefit of fluent interfaces in Java is they offer a cheap user interface for configuration of APIs by leveraging your IDE's autocomplete capability. All other benefits are orthogonal. Sorry but if I didn't call them that, someone else would. Applicative Programming with Effects, Conor McBride and Ross Paterson. (2008) http://www.staff.city.ac.uk/~ross/papers/Applicative.html \"A man of genius makes no mistakes. His errors are volitional and are the portals to discovery.\" - James Joyce, Ulysses","title":"Philosophy"},{"location":"philosophy-lang/#eucalypt-the-language","text":"eucalypt , the language, is unorthodox in many respects - probably moreso than you might realise on first acquaintance. Many people have deep-seated and inflexible opinions about programming languages and language design 1 and will likely find something in here that they have a kneejerk reaction against. However, the design is not unprincipled and, while it is experimental in some respects, I believe it's internally consistent. Several aspects of the design and the aesthetic are driven by the primary use case. Maybe by exploring some of the inspiration and philosophy behind the language itself, I can head off potential criticism.","title":"eucalypt (the language)"},{"location":"philosophy-lang/#accept-crypticality-for-minimal-intrusion","text":"eucalypt is first and foremost a tool , rather than a language. It is intended to replace generation and transformation processes on semi-structured data formats. Many or most uses of eucalypt the language should just be simple one-liner tags in YAML files, or maybe eucalypt files that are predominantly data rather than manipulation. The eucalypt language is the depth behind these one-liners that allows eucalypt to accommodate increasingly ambitious use cases without breaking the paradigm and reaching for a general purpose scripting language. 2 The pre-eminence of one-liners and small annotations and \"logic mark-up\", means that eucalypt often favours concise and cryptic over wordy and transparent. This is a controversial approach. eucalypt logic should \"get out of the way\" of the data. Templating is attractive precisely because the generating source looks very like the result. Template tags are often short (with \"cryptic\" delimiters - {{}} , %= % , [| ] ...) because these are \"marking up\" the data which is the main event. At the same time, the tags are often \"noisy\" or visually disruptive to ensure they cannot be ignored. eucalypt via operator and bracket definitions, picks and chooseS from a similar palette of expressive effects to try and be a sympathetic cohabitee with its accompanying data. There are many cases where it makes sense to resist offering an incomplete understanding in favour of demanding full understanding. For example, it is spurious to say that bind(x, f) gives more understanding of what is going on than x = f - unless you understand the monad abstraction and the role of bind in it, you gain nothing from the ideas that the word bind conveys when trying to understand program text. eucalypt just plain ignores the notion that program text should be readable as English text. This (well motivated) idea has made a resurgence in recent years through the back door of internal DSLs and \"fluent\" Java interfaces 3 . There is much merit in languages supple enough to allow the APIs to approach the natural means of expression of the problem domain. However, problem domains frequently have their own technical jargon and notation which suit their purpose better than natural language so it cuts both ways. Program text should be approachable by its target audience but that does not mean it should make no demands of its target audience. These stances lead directly to several slightly esoteric aspects of eucalypt that may be obnoxious to some: eucalypt tends to be operator-heavy. Operators are concise (if cryptic) and the full range of unicode is available to call upon. Using operators keeps custom logic visually out of the way of the data whilst also signposting it to attract closer attention. eucalypt lets you define your own operators and specify their precedence and associativity (which are applied at a relatively late stage in the evaluation pipeline - operator soup persists through the initial parse). There are no ternary operators. For absolute minimal intrusion, merely the act of placing elements next to each other (\"catenation\"), x f , is meaningful in eucalypt . By default this is pipeline-order function application, but blocks and lists can be applied as functions to make common transformations, like block merge, very succinct. For even more power, eucalypt lets you alter the meaning of concatenation via idiot brackets 4 . This is inspired by the idiom brackets that can be used to express applicative styles in functional programming 5 . These also provide an acceptable proxy for ternary and other operators too. An equivalent generalisation of eucalypt block syntax to provide a capability similar to Haskell's do notation might follow.","title":"Accept crypticality for minimal intrusion"},{"location":"philosophy-lang/#cohabitation-of-code-and-data","text":"Just like templates, eucalypt source (or eucalypt -tagged YAML or JSON) should be almost entirely data. The idea behind eucalypt is to adopt the basic maps-and-arrays organisation philosophy of these data formats but make the data active - allowing lambdas to live in and amongst it and operate on it and allowing the data to express dispositions towards its environment by addition of metadata that controls import, export, and execution preferences. eucalypt therefore collapses the separation of code and data to some degree. You can run eu against a mixture of YAML, JSON and eucalypt files and all the data and logic appears there together in the same namespace hierarchy. The namespace hierarchy just is the data. However, code and data aren't unified in the sense of Lisp for instance. eucalypt is not homoiconic. The relationship is more like cohabitation; code lives in amongst the data it operates on but is stripped out before export. Nevertheless eucalypt is heavily inspired by Lisp and aims for a similar fluidity though: lazy evaluation (encompassing uses of Lisp macros which control evaluation order - if is) economical syntax and syntactic reinterpretability (idiot brackets)","title":"Cohabitation of code and data"},{"location":"philosophy-lang/#simplicity","text":"eucalypt values simplicity in the sense of fewer moving parts (and therefore, hopefully, fewer things to go wrong). It values ease of use in the sense of offering a rich and powerful toolkit. You may not think it achieves either. eucalypt values familiarity more in the \"shallower\" parts of the language where it only requires a couple of mental leaps for the average programmer in these areas - (ab)use of catenation being the key one. However, eucalypt shouldn't be ashamed of its dusty corners. Dusty corners are areas where novices and experts alike can get trapped and lose time but they're also rich seams for experimentation, innovation and discovery 6 . If you have to venture too far off-piste to find what you need, we'll find a way to bring it onto the nursery slopes but we won't close off the mountain.","title":"Simplicity"},{"location":"philosophy-lang/#footnotes","text":"...often a result of underfamiliarity with the alternatives. For some reason, I think of this rather like the historical passages in The Lord of the Rings; they give a tremendous sense of the depth of the world, that everywhere you look there is a rich culture and background staring back at you. You trust that it's all coherent and all there if you need it but are generally happy to be led through the main narrative over the surface of this rich mythology. Actually the key benefit of fluent interfaces in Java is they offer a cheap user interface for configuration of APIs by leveraging your IDE's autocomplete capability. All other benefits are orthogonal. Sorry but if I didn't call them that, someone else would. Applicative Programming with Effects, Conor McBride and Ross Paterson. (2008) http://www.staff.city.ac.uk/~ross/papers/Applicative.html \"A man of genius makes no mistakes. His errors are volitional and are the portals to discovery.\" - James Joyce, Ulysses","title":"Footnotes"}]}
# -*- mode: conf -*-

# doesn't require prelude; uses builtins only

(l=r): __EQ(l, r)
cons(l, r): __CONS(l, r)
block(l): __BLOCK(l)
elements(b): __ELEMENTS(b)

block1: {
  k: 1
  z: "hello"
  bibble-wibble: :a
}

block2: block1

items: block2 elements

block3: items block

block4: cons([:x, 9999], items) block

block5: [[:x, 9999], [:k, 1], [:z, "hello"], [:bibble-wibble, :a]] block

checks: {
  trues: {
    a: block3=block2
    b: ({ a: 1 } elements block) = { a: 1 }
    c: block5=block5
  }
}

merging: {
  m: { a: 2 } { b: 3 }
  m2: ({ a: 2 } { a: 3 })
  a: m.a
  a2: m2.a
  checks: {
    trues: {
      a: ({ a: 2 } { b: 3 }) = { a: 2 b: 3 }
      b: ({ a: 2 } { a: 3 }) = { a: 3 }
      c: ({ a: 1 b: 2 c: 3 d: 4} { b: 1 c: 1 d: 1}) = { a:1 b:1 c:1 d:1 }
    }
  }

  merge: __MERGE
  merge-with(r, l): merge(l, r)
  with-tags: merge-with({tags: [:a, :b, :c]})

  m-tagged: m with-tags
  m2-tagged: m2 with-tags
  checks: {
    trues: [
      m-tagged = { a: 2 b: 3 tags:[:a, :b, :c]},
      m2-tagged = { a: 3 tags:[:a, :b, :c]}
    ]
  }

}


lookups: {

  page1: {
    title: "page one"
    body: "blah blah"
  }

  page2: {
    title: "page two"
    body: "blah blah"
  }

  page3: {
    title: "page three"
    body: "blah blah"
    epilogue: "."
  }

  lookup: __LOOKUP
  lookup-or: __LOOKUPOR
  head: __HEAD
  tail: __TAIL
  map(f, l): if(l nil?, l, cons(l head f, l tail map(f)))

  pages: [page1, page2, page3]

  title: lookup(:title)
  epilogue: lookup-or(:epilogue, "x")

  titles: pages map(title)
  epilogues: pages map(epilogue)

  checks: {
    trues: [
      titles = ["page one", "page two", "page three"],
      epilogues = ["x", "x", "."],
      (pages map(lookup(:title))) = (pages map(lookup("title")))
    ]
  }
}

pass: [ checks.trues values all-true?
      , merging.checks.trues values all-true?
      , lookups.checks.trues all-true?] all-true?

RESULT: if(pass, :PASS, :FAIL)
